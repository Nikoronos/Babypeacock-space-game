<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,user-scalable=no" />
<title>Babypeacock ‚Äî BPC Mini Space Game</title>
<style>
  html,body{margin:0;height:100%;background:#000;font-family:system-ui,Segoe UI,Roboto,Arial}
  #brand{position:fixed;top:6px;left:12px;z-index:4;font-weight:900;letter-spacing:.3px;
    background:linear-gradient(90deg,#22d3ee,#34d399);-webkit-background-clip:text;background-clip:text;color:transparent;
    text-shadow:0 0 10px rgba(34,211,238,.35),0 0 14px rgba(52,211,153,.25)}
  #brand small{opacity:.9;font-weight:700}
  #score{position:fixed;top:8px;left:0;right:0;text-align:center;color:#00ffc8;font-weight:700;z-index:4}
  #power{position:fixed;top:8px;right:10px;color:#a7f3d0;font-weight:700;z-index:4}
  #lives{position:fixed;bottom:10px;left:0;right:0;text-align:center;color:#f87171;font-weight:700;z-index:4}
  #gameOver,#startOverlay{position:fixed;inset:0;display:none;align-items:center;justify-content:center;flex-direction:column;
    background:rgba(0,0,0,.82);color:#fff;font-size:20px;font-weight:800;z-index:6;text-align:center}
  .btn{margin-top:12px;padding:12px 22px;border:1px solid #00ffc8;background:#0b1220;color:#00ffc8;border-radius:12px;font-weight:900;letter-spacing:.3px}
  canvas{display:block;margin:44px auto 0 auto;background:#020617;
    touch-action:none;-webkit-user-select:none;user-select:none;width:min(420px,96vw);height:auto;max-height:92vh}
</style>
</head>
<body>
  <div id="brand">Babypeacock ü¶ö<br><small>arcade</small></div>
  <div id="score">ü¶ö Score: <span id="sc">0</span></div>
  <div id="power">üíé x <span id="px">0</span></div>
  <div id="lives">‚ù§Ô∏è‚ù§Ô∏è‚ù§Ô∏è</div>

  <div id="startOverlay">
    <div style="margin-bottom:8px">üéÆ Ready to play?</div>
    <div style="font-size:14px;opacity:.85;margin-bottom:10px">Hold & drag to move ‚Ä¢ Auto fire while holding</div>
    <button id="startBtn" class="btn" type="button">START</button>
    <div style="font-size:12px;opacity:.7;margin-top:8px">Tap anywhere to start</div>
  </div>

  <div id="gameOver">
    <div>üíÄ Game Over üíÄ</div>
    <button id="restart" class="btn" type="button">Restart</button>
  </div>

  <canvas id="game" width="420" height="700"></canvas>

  <audio id="boom" preload="auto" playsinline>
    <source src="https://cdn.pixabay.com/audio/2022/03/15/audio_2b1b0dcd8c.mp3" type="audio/mpeg">
  </audio>

<script>
/* ====== Canvas & HUD ====== */
const cv=document.getElementById("game"),ctx=cv.getContext("2d");
ctx.imageSmoothingEnabled=false;
const scEl=document.getElementById("sc"),pxEl=document.getElementById("px"),
      livesEl=document.getElementById("lives"),
      overEl=document.getElementById("gameOver"),
      restartBtn=document.getElementById("restart"),
      startOverlay=document.getElementById("startOverlay"),
      startBtn=document.getElementById("startBtn"),
      boom=document.getElementById("boom");

/* ====== Utils ====== */
function loadImage(src){return new Promise((res,rej)=>{const i=new Image();i.crossOrigin="anonymous";i.onload=()=>{i.dataset={src};res(i)};i.onerror=rej;i.src=src;});}
function keyOutDark(img,TH=80){
  const w=img.width,h=img.height,off=document.createElement("canvas");
  off.width=w;off.height=h;const ox=off.getContext("2d");ox.drawImage(img,0,0);
  const d=ox.getImageData(0,0,w,h),a=d.data;
  for(let p=0;p<a.length;p+=4){
    const r=a[p],g=a[p+1],b=a[p+2],lum=0.2126*r+0.7152*g+0.0722*b;
    if((r<TH&&g<TH&&b<TH)||lum<TH*0.8)a[p+3]=0; else if(lum<TH*1.1)a[p+3]=Math.max(0,a[p+3]-120);
  }
  ox.putImageData(d,0,0); return off;
}
function clamp(v,min,max){return v<min?min:(v>max?max:v);}
function rectHit(a,b){ return !(a.x+a.w<b.x||a.x>b.x+b.w||a.y+a.h<b.y||a.y>b.y+b.h); }

/* ====== Assets ====== */
const PLAYER_SRC="img/player/bpc_mini.png";
const ENEMY_SRCS=[
  "bpc_enemy_green.png", // green: lazer (down, 500ms)
  "bpc_enemy_red.png",   // red: bullet (down, 500ms)
  "bpc_enemy_ufo_gray.png",
  "bpc_enemy_ufo_red.png"
];

/* ====== State ====== */
const bullets=[], enemies=[], gems=[], particles=[], enemyBullets=[];
let score=0,powerShots=0,holding=false,pointerId=null,fireTimer=0,FIRE_MS=170;
let lives=3,gameOver=false, started=false;
const player={x:cv.width/2-33,y:cv.height-120,w:66,h:66};

/* ====== Background stars ====== */
const density=(cv.width<380?0.6:(cv.width<420?0.8:1));
const starA=[], starB=[];
for(let i=0;i<Math.round(40*density);i++) starA.push({x:Math.random()*cv.width,y:Math.random()*cv.height});
for(let i=0;i<Math.round(25*density);i++) starB.push({x:Math.random()*cv.width,y:Math.random()*cv.height});
const starAV=0.4*density, starBV=0.9*density;

/* ====== Start / overlays ====== */
function startGame(){ if(started) return; started=true; startOverlay.style.display='none'; }
startOverlay.style.display="flex";
["click","pointerdown","touchstart"].forEach(ev=>{
  startBtn.addEventListener(ev,startGame,{passive:false});
  startOverlay.addEventListener(ev,startGame,{passive:false});
});
["pointerdown","touchstart","mousedown"].forEach(ev=>{
  document.body.addEventListener(ev,startGame,{once:true,passive:true});
  cv.addEventListener(ev,startGame,{once:true,passive:true});
});
window.addEventListener("keydown",(e)=>{ if(e.key===" "||e.key==="Enter") startGame(); });

/* ====== Controls ====== */
function canvasXFromEvent(e){ const r=cv.getBoundingClientRect(); const cx=(e.clientX!==undefined)?e.clientX:(e.touches?e.touches[0].clientX:0); return cx-r.left; }
function startPointer(e){ if(!started) return; if(holding) return; holding=true; if(e.pointerId!==undefined){pointerId=e.pointerId; cv.setPointerCapture(pointerId);} movePointer(e); e.preventDefault(); }
function movePointer(e){ if(!started||!holding) return; if(e.pointerId!==undefined && pointerId!==null && e.pointerId!==pointerId) return;
  const x=canvasXFromEvent(e)-player.w/2; player.x=clamp(x,0,cv.width-player.w); e.preventDefault(); }
function endPointer(e){ if(!holding) return; if(e.pointerId!==undefined && pointerId!==null && e.pointerId!==pointerId) return;
  holding=false; if(pointerId!==null){try{cv.releasePointerCapture(pointerId);}catch{} pointerId=null;} e.preventDefault(); }
cv.addEventListener("pointerdown",startPointer,{passive:false});
cv.addEventListener("pointermove",movePointer,{passive:false});
cv.addEventListener("pointerup",endPointer,{passive:false});
cv.addEventListener("pointercancel",endPointer,{passive:false});

/* ====== Player Fire ====== */
function addBullet(x,vy,ang){ if(bullets.length>24) return; bullets.push({x,y:player.y-12,w:4,h:12,vy,ang}); }
function shoot(){
  if(powerShots>0){ addBullet(player.x+player.w/2-2,-10,0); addBullet(player.x+player.w/2-2,-10,-3); addBullet(player.x+player.w/2-2,-10, 3); powerShots--; pxEl.textContent=powerShots; }
  else addBullet(player.x+player.w/2-2,-10,0);
}

/* ====== Enemies ====== */
function kindFromImg(img){ const s=img?.dataset?.src?.toLowerCase?.()||""; if(s.includes("green")) return "green"; if(s.includes("red")) return "red"; return "other"; }

function spawnEnemy(){
  if(enemies.length>10) return;
  let img=null; if(enemiesImgs && enemiesImgs.length>0) img=enemiesImgs[Math.floor(Math.random()*enemiesImgs.length)];
  const size=52+Math.random()*24;
  const kind=kindFromImg(img);
  enemies.push({
    x:Math.random()*(cv.width-size),
    y:-size,
    w:size,h:size,
    vy:(1.4+Math.random()*2.1)*density,
    img, kind,
    shootT:0, shootInterval:500 // üî• 0.5s per shot
  });
}

/* ====== Enemy shooting (straight down) ====== */
function enemyShoot(e){
  const cx=e.x+e.w/2, top=e.y+e.h;
  if(e.kind==="red"){
    enemyBullets.push({x:cx-2,y:top,w:4,h:12,vy:5.0,color:"#ef4444"});
  }else if(e.kind==="green"){
    enemyBullets.push({x:cx-1,y:top,w:2,h:18,vy:5.8,color:"#22c55e"});
  } // 'other' types don't shoot
}

/* ====== Gem / Particles ====== */
function spawnGem(){ if(gems.length>5) return; const s=24; gems.push({x:Math.random()*(cv.width-s),y:-s,w:s,h:s,vy:1.6*density}); }
function explosion(x,y,count=12){
  const maxLeft=60-particles.length; const n=Math.max(0,Math.min(count,maxLeft));
  for(let i=0;i<n;i++){ const ang=Math.random()*6.283, sp=(1.2+Math.random()*2.6)*density;
    particles.push({x,y,vx:Math.cos(ang)*sp,vy:Math.sin(ang)*sp,life:320+Math.random()*200,size:2+Math.random()*2.5});
  }
  try{boom.currentTime=0; boom.play().catch(()=>{});}catch{}
}

/* ====== Loop ====== */
let spawnT=0, gemT=0;
function update(dt){
  // stars
  for(const s of starA){ s.y+=starAV; if(s.y>cv.height){ s.y=0; s.x=Math.random()*cv.width; } }
  for(const s of starB){ s.y+=starBV; if(s.y>cv.height){ s.y=0; s.x=Math.random()*cv.width; } }

  if(gameOver || !started) return;

  // player fire
  fireTimer+=dt; if(holding && fireTimer>FIRE_MS){ shoot(); fireTimer=0; }

  // player bullets
  for(let i=bullets.length-1;i>=0;i--){ const b=bullets[i]; b.y+=b.vy; b.x+=(b.ang||0)*0.55; if(b.y<-20) bullets.splice(i,1); }

  // enemies move + shoot
  spawnT+=dt; if(spawnT>750){ spawnEnemy(); spawnT=0; }
  enemies.forEach(e=>{
    e.y+=e.vy;
    e.shootT+=dt;
    if(e.shootT>=e.shootInterval){ e.shootT=0; enemyShoot(e); }
  });
  for(let i=enemies.length-1;i>=0;i--){
    if(enemies[i].y>cv.height+10){
      enemies.splice(i,1);
      lives--; updateLivesDisplay(); if(lives<=0){ endGame(); return; }
    }
  }

  // gem
  gemT+=dt; if(gemT>5600){ spawnGem(); gemT=0; }
  gems.forEach(g=>{ g.y+=g.vy; });
  for(let i=gems.length-1;i>=0;i--) if(gems[i].y>cv.height+40) gems.splice(i,1);

  // player bullet -> enemy
  for(let i=enemies.length-1;i>=0;i--){
    const e=enemies[i];
    for(let j=bullets.length-1;j>=0;j--){
      const b=bullets[j];
      if(rectHit({x:b.x,y:b.y,w:b.w,h:b.h},e)){
        explosion(e.x+e.w/2,e.y+e.h/2,14);
        enemies.splice(i,1); bullets.splice(j,1);
        score++; scEl.textContent=score; break;
      }
    }
  }

  // player -> gem
  for(let i=gems.length-1;i>=0;i--){ const g=gems[i]; if(rectHit(player,g)){ gems.splice(i,1); powerShots+=3; pxEl.textContent=powerShots; } }

  // player -> enemy collision
  for(let i=enemies.length-1;i>=0;i--){
    const e=enemies[i];
    if(rectHit(player,e)){
      explosion(player.x+player.w/2,player.y+player.h/2,20);
      enemies.splice(i,1);
      lives--; updateLivesDisplay(); if(lives<=0){ endGame(); } 
      break;
    }
  }

  // enemy bullets -> player
  for(let i=enemyBullets.length-1;i>=0;i--){
    const m=enemyBullets[i];
    m.y+=m.vy;
    if(m.y>cv.height+30){ enemyBullets.splice(i,1); continue; }
    if(rectHit(player,m)){
      enemyBullets.splice(i,1);
      lives--; updateLivesDisplay(); if(lives<=0){ endGame(); return; }
    }
  }

  // particles
  for(let i=particles.length-1;i>=0;i--){
    const p=particles[i]; p.life-=dt; if(p.life<=0){ particles.splice(i,1); continue; }
    p.x+=p.vx; p.y+=p.vy; p.vy+=0.018;
  }
}

function draw(){
  ctx.clearRect(0,0,cv.width,cv.height);
  // stars
  ctx.fillStyle="rgba(190,220,255,.8)"; for(const s of starA) ctx.fillRect(s.x,s.y,1,1);
  ctx.fillStyle="rgba(255,255,255,.9)";  for(const s of starB) ctx.fillRect(s.x,s.y,1.2,1.2);

  // player
  if(playerImgKeyed) ctx.drawImage(playerImgKeyed, player.x, player.y, player.w, player.h);
  else { ctx.fillStyle="#38bdf8"; ctx.fillRect(player.x,player.y,player.w,player.h); }

  // player bullets
  ctx.fillStyle="#00ffc8"; bullets.forEach(b=>ctx.fillRect(b.x,b.y,b.w,b.h));

  // enemies
  enemies.forEach(e=>{
    if(e.img) ctx.drawImage(e.img,e.x,e.y,e.w,e.h);
    else { ctx.fillStyle="#ef4444"; ctx.fillRect(e.x,e.y,e.w,e.h); }
  });

  // enemy bullets (colored)
  enemyBullets.forEach(m=>{
    ctx.fillStyle=m.color||"#ff4444";
    ctx.fillRect(m.x,m.y,m.w,m.h);
  });

  // gem (gift) ‚Äî LIGHT BLUE to avoid green confusion
  ctx.fillStyle="#38bdf8";
  ctx.strokeStyle="#0e7490";
  ctx.lineWidth=1.6;
  gems.forEach(g=>{
    const {x,y,w,h}=g;
    ctx.fillRect(x+w*0.25,y+h*0.2,w*0.5,h*0.6);
    ctx.strokeRect(x+w*0.25,y+h*0.2,w*0.5,h*0.6);
  });

  // particles
  ctx.fillStyle="rgba(255,200,80,.9)";
  particles.forEach(p=>{ const a=Math.max(0,p.life/400); ctx.globalAlpha=a; ctx.beginPath(); ctx.arc(p.x,p.y,p.size,0,6.283); ctx.fill(); ctx.globalAlpha=1; });
}

/* ====== Lives / Endgame ====== */
function updateLivesDisplay(){ livesEl.innerHTML="‚ù§Ô∏è".repeat(lives); }
function endGame(){ gameOver=true; overEl.style.display="flex"; }
restartBtn.onclick=()=>{ 
  score=0; powerShots=0; lives=3; gameOver=false;
  bullets.length=enemies.length=gems.length=particles.length=enemyBullets.length=0;
  scEl.textContent=score; pxEl.textContent=powerShots; updateLivesDisplay();
  overEl.style.display="none"; started=false; startOverlay.style.display='flex';
};

/* ====== RAF loop ====== */
function loop(t){ let dt=t-(window._lt||t); window._lt=t; if(dt>32) dt=32; update(dt); draw(); requestAnimationFrame(loop); }
requestAnimationFrame(loop);

/* ====== Preload ====== */
let playerImgKeyed=null, enemiesImgs=[];
(async function(){
  try{ const p=await loadImage(PLAYER_SRC); playerImgKeyed=keyOutDark(p,80); }catch{ playerImgKeyed=null; }
  enemiesImgs=[];
  for(const s of ENEMY_SRCS){
    try{ const i=await loadImage(s); const keyed=keyOutDark(i,80); keyed.dataset={src:s}; enemiesImgs.push(keyed); }
    catch{}
  }
})();
updateLivesDisplay();
</script>
</body>
</html>
