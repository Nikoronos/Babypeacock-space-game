<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1" />
<title>BPC ‚Äî Anti-tamper Score Demo</title>
<style>
  html,body{height:100%;margin:0;background:#000;font-family:Inter,system-ui,Arial}
  #ui{position:fixed;left:0;right:0;top:6px;display:flex;justify-content:space-between;padding:0 12px;z-index:8;color:#00ffc8;font-weight:700}
  #lives{position:fixed;left:0;right:0;bottom:10px;text-align:center;color:#ff6b81;z-index:8}
  #startOverlay,#gameOver{position:fixed;inset:0;display:flex;align-items:center;justify-content:center;flex-direction:column;
    background:rgba(0,0,0,.82);z-index:9;color:#fff}
  .btn{background:#072026;border:2px solid #06d6b8;color:#06d6b8;padding:10px 18px;border-radius:12px;font-weight:800}
  canvas{display:block;margin:48px auto 0 auto;background:#020617;width:min(420px,96vw);height:auto;max-height:88vh}
  #smallNote{font-size:12px;opacity:.8;margin-top:8px;color:#9be7ff}
</style>
</head>
<body>
  <div id="ui">
    <div id="brand">Babypeacock</div>
    <div id="scoreHUD">Score: <span id="sc">0</span></div>
    <div id="powerHUD">üíé <span id="px">0</span></div>
  </div>
  <div id="lives">‚ù§Ô∏è‚ù§Ô∏è‚ù§Ô∏è</div>

  <div id="startOverlay">
    <div style="font-weight:800;font-size:18px;margin-bottom:8px">Hold & drag to move ‚Äî auto fire</div>
    <button id="startBtn" class="btn">START</button>
    <div id="smallNote">When game ends, final score appears on the canvas (hard to edit).</div>
  </div>

  <div id="gameOver" style="display:none">
    <!-- overlay still visible for restart button, but final score will be drawn on canvas (not in DOM) -->
    <div style="font-weight:900;font-size:20px;margin-bottom:10px">GAME OVER</div>
    <button id="restart" class="btn">RESTART</button>
  </div>

  <canvas id="game" width="420" height="700"></canvas>

<script>
/* ========= Minimal game + anti-tamper final scoreboard ========= */

const cv = document.getElementById('game'), ctx = cv.getContext('2d'); ctx.imageSmoothingEnabled=false;
const scDOM = document.getElementById('sc'), pxDOM = document.getElementById('px'), livesDOM = document.getElementById('lives');
const startOverlay = document.getElementById('startOverlay'), startBtn = document.getElementById('startBtn');
const overEl = document.getElementById('gameOver'), restartBtn = document.getElementById('restart');
let score = 0, lives = 3, started = false, gameOver = false;
let bullets = [], enemies = [], particles = [], gems = [], mascots = [];
let fireTimer=0, FIRE_MS=180, powerTime=0;
let elapsed=0, spawnTimer=0;
const player = { x: cv.width/2-28, y: cv.height-120, w:56, h:56 };

/* small star background */
const stars=[];
for(let i=0;i<80;i++) stars.push({x:Math.random()*cv.width,y:Math.random()*cv.height,r:Math.random()*1.6});

/* controls */
let holding=false;
function startGame(){ if(started) return; started=true; startOverlay.style.display='none'; }
startBtn.onclick = startGame;
cv.addEventListener('pointerdown', e=>{ if(!started) return; holding=true; move(e); });
cv.addEventListener('pointermove', e=>{ if(holding) move(e); });
cv.addEventListener('pointerup', ()=>holding=false);
function move(e){ const r=cv.getBoundingClientRect(); const cx=(e.clientX ?? (e.touches?e.touches[0].clientX:0)) - r.left; player.x = Math.max(0, Math.min(cv.width-player.w, cx-player.w/2)); }

/* simple drawing helpers */
function rectHit(a,b){ return !(a.x+a.w<b.x || a.x>b.x+b.w || a.y+a.h<b.y || a.y>b.y+b.h); }
function rand(a,b){ return a + Math.random()*(b-a); }

/* preload optional images (coin logo) */
let coinImgCanvas = null;
(async function(){
  try{
    const img = new Image(); img.crossOrigin='anonymous'; img.src='bpc_coin.png';
    await new Promise((res,rej)=>{ img.onload=res; img.onerror=rej; });
    // key out dark background
    const off = document.createElement('canvas'); off.width=img.width; off.height=img.height;
    const g=off.getContext('2d'); g.drawImage(img,0,0);
    const id = g.getImageData(0,0,off.width,off.height);
    for(let i=0;i<id.data.length;i+=4){
      const r=id.data[i],gg=id.data[i+1],b=id.data[i+2],lum = 0.2126*r+0.7152*gg+0.0722*b;
      if((r<90&&gg<90&&b<90) || lum < 70) id.data[i+3]=0;
    }
    g.putImageData(id,0,0);
    coinImgCanvas = off;
  }catch(e){ coinImgCanvas = null; }
})();

/* spawn & update */
function spawnEnemy(){
  const s = rand(38,68);
  enemies.push({ x: rand(0, cv.width-s), y: -s, w:s, h:s, vy: rand(0.9,2.2) });
}
function shoot(){ bullets.push({ x: player.x+player.w/2-2, y: player.y, w:4, h:10, vy:-9 }); }
function explosion(x,y,n=12){
  for(let i=0;i<n;i++){
    const a=Math.random()*Math.PI*2, sp=1+Math.random()*2.2;
    particles.push({ x, y, vx:Math.cos(a)*sp, vy:Math.sin(a)*sp, life: 300+Math.random()*300, s:1.6+Math.random()*2.4 });
  }
}

/* anti-tamper checksum (simple) */
function shortChecksum(str){
  // simple 16-bit-like checksum rendered as 4 hex chars, deterministic
  let h=2166136261;
  for(let i=0;i<str.length;i++){
    h ^= str.charCodeAt(i);
    h += (h<<1) + (h<<4) + (h<<7) + (h<<8) + (h<<24);
  }
  // reduce and hex
  h = Math.abs(h) % 0xFFFF;
  return ("000"+h.toString(16)).slice(-4).toUpperCase();
}

/* game over: draw final scoreboard ON CANVAS (no DOM text) */
function drawFinalCanvasScore(){
  // darken screen
  ctx.save();
  ctx.fillStyle = "rgba(0,0,0,0.66)";
  ctx.fillRect(0,0,cv.width,cv.height);

  // draw coin logo if available
  if(coinImgCanvas){
    const W=120, H=120;
    ctx.drawImage(coinImgCanvas, cv.width/2 - W/2, cv.height/2 - 160, W, H);
  }

  // big score text (canvas pixels)
  ctx.fillStyle = "#00FFC8";
  ctx.textAlign = "center";
  ctx.font = "bold 36px Inter, Arial";
  ctx.fillText("Score: " + score, cv.width/2, cv.height/2 - 20);

  // timestamp + checksum (small, to make montage harder)
  const now = new Date();
  const ts = now.toISOString().replace('T',' ').slice(0,19); // 2025-01-01 12:12:12
  const payload = `S${score}|${ts}`;
  const cs = shortChecksum(payload);
  ctx.font = "12px Inter, Arial";
  ctx.fillStyle = "#9be7ff";
  ctx.fillText(`${ts}  ¬∑  CS:${cs}`, cv.width/2, cv.height/2 + 14);

  // optional instruction small
  ctx.font="11px Inter, Arial"; ctx.fillStyle="#9bd9c7";
  ctx.fillText("This final score is rendered on the game canvas (hard to edit).", cv.width/2, cv.height/2 + 42);
  ctx.restore();
}

/* update loop */
let last=0;
function update(dt){
  if(!started) return;
  if(gameOver) return;

  elapsed += dt;
  spawnTimer += dt;

  // firing while holding
  fireTimer += dt;
  if(holding && fireTimer > FIRE_MS){ shoot(); fireTimer = 0; }

  // spawn
  if(spawnTimer > 800){ spawnEnemy(); spawnTimer = 0; }

  // bullets
  for(let i=bullets.length-1;i>=0;i--){
    bullets[i].y += bullets[i].vy;
    if(bullets[i].y < -20) bullets.splice(i,1);
  }

  // enemies
  for(let i=enemies.length-1;i>=0;i--){
    enemies[i].y += enemies[i].vy * (score>=300?1.4:1);
    if(enemies[i].y > cv.height + 30){ enemies.splice(i,1); lives--; updateLives(); if(lives<=0) doGameOver(); continue; }
  }

  // bullets vs enemies
  for(let i=enemies.length-1;i>=0;i--){
    const e=enemies[i];
    for(let j=bullets.length-1;j>=0;j--){
      if(rectHit(e, bullets[j])){
        explosion(e.x+e.w/2, e.y+e.h/2, 14);
        enemies.splice(i,1); bullets.splice(j,1);
        score++; scDOM.textContent = score;
        break;
      }
    }
  }

  // particles
  for(let i=particles.length-1;i>=0;i--){
    particles[i].life -= dt;
    if(particles[i].life <= 0) particles.splice(i,1);
    else { particles[i].x += particles[i].vx; particles[i].y += particles[i].vy; particles[i].vy += 0.02; }
  }
}

function updateLives(){ livesDOM.innerHTML = "‚ù§Ô∏è".repeat(Math.max(0,lives)); }

/* handle game over flow */
function doGameOver(){
  gameOver = true;
  // hide DOM HUD values so attacker can't just screenshot DOM
  document.getElementById('ui').style.display = 'none';
  document.getElementById('lives').style.display = 'none';
  // show overlay restart UI (but final score drawn on canvas)
  overEl.style.display = 'flex';
  // also immediately draw final canvas score
  drawFinalCanvasScore();
}

/* draw loop */
function draw(){
  // background
  ctx.fillStyle = "#020617"; ctx.fillRect(0,0,cv.width,cv.height);

  // stars
  ctx.fillStyle="rgba(255,255,255,0.9)";
  for(const s of stars) ctx.fillRect(s.x, s.y, s.r, s.r);

  // player
  ctx.fillStyle="#2dd4bf"; ctx.fillRect(player.x, player.y, player.w, player.h);

  // bullets
  ctx.fillStyle="#00ffc8"; for(const b of bullets) ctx.fillRect(b.x, b.y, b.w, b.h);

  // enemies
  ctx.fillStyle="#ef4444"; for(const e of enemies) ctx.fillRect(e.x, e.y, e.w, e.h);

  // particles
  for(const p of particles){
    const a = Math.max(0, p.life/500);
    ctx.globalAlpha = a;
    ctx.fillStyle = "rgba(255,200,80,1)"; ctx.beginPath(); ctx.arc(p.x, p.y, p.s, 0, Math.PI*2); ctx.fill();
    ctx.globalAlpha = 1;
  }

  // If gameOver, ensure final canvas score is visible (drawn once, but redraw to remain)
  if(gameOver){
    drawFinalCanvasScore(); // redraw overlay score every frame to avoid DOM restore tricks
  }
}

/* main loop */
function frame(ts){
  if(!last) last = ts;
  const dt = Math.min(ts - last, 40);
  last = ts;
  update(dt);
  draw();
  requestAnimationFrame(frame);
}
requestAnimationFrame(frame);

/* events */
restartBtn.onclick = ()=>{
  // reset and restore HUD
  score = 0; scDOM.textContent = 0;
  lives = 3; updateLives();
  bullets = []; enemies = []; particles = []; gems=[]; mascots=[];
  started = false; gameOver=false;
  document.getElementById('ui').style.display = 'flex';
  document.getElementById('lives').style.display = 'block';
  overEl.style.display = 'none';
  startOverlay.style.display = 'flex';
};

/* quick start via overlay click */
cv.addEventListener('click', ()=>{ if(!started) startGame(); });

/* small helpful debugging: space to kill (dev only, remove in prod) */
window.addEventListener('keydown', e=>{
  if(e.key === 'k'){ doGameOver(); }
});

</script>
</body>
</html>
