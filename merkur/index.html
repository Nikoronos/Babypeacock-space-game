<!doctype html>
<html lang="tr">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover,user-scalable=no" />
<title>BPC Space — Mars (Level 2)</title>
<style>
  :root{color-scheme:dark;}
  html,body{margin:0;height:100%;background:#000;overscroll-behavior:none}
  body{font-family:system-ui,Segoe UI,Roboto,Helvetica,Arial,sans-serif;}
  #wrap{position:fixed;inset:0;display:grid;grid-template-rows:auto 1fr;}
  header{
    height:50px;background:linear-gradient(180deg,#060a12,rgba(6,10,18,.6));
    color:#bcd3ff;display:flex;align-items:center;gap:14px;padding:0 12px;font-weight:700;
    text-shadow:0 1px 0 #000;
  }
  header .title{font-size:24px;letter-spacing:.3px}
  header .tag{opacity:.9;font-weight:700}
  header .score{margin-left:auto}
  #game{display:block;width:100%;height:100%;background:#0b0f17}
  /* Start / GameOver overlay */
  .overlay{
    position:fixed;inset:0;background:rgba(0,0,0,.65);
    display:flex;align-items:center;justify-content:center;z-index:9;backdrop-filter:saturate(110%) blur(2px);
  }
  .card{
    background:#0b1320;border:1px solid rgba(255,255,255,.08);
    border-radius:14px;box-shadow:0 10px 30px rgba(0,0,0,.45);
    padding:20px;max-width:92vw;width:420px;text-align:center;color:#dfe8ff;
  }
  .card h1{margin:0 0 8px;font-size:26px}
  .card p{margin:0 0 16px;opacity:.9}
  .btn{
    display:inline-block;background:#0bb3a8;color:#021e1c;font-weight:800;
    padding:12px 18px;border-radius:12px;border:none;cursor:pointer;font-size:18px;
    box-shadow:0 6px 14px rgba(11,179,168,.35);
  }
  .btn:active{transform:translateY(1px)}
  /* Mobile touch hint */
  .hint{font-size:12px;opacity:.7;margin-top:8px}
  canvas{touch-action:none}
</style>
</head>
<body>
  <div id="wrap">
    <header>
      <div class="title">Babypeacock 🦚</div>
      <div class="tag">Mars (Level 2)</div>
      <div class="score">Score: <span id="scoreTxt">0</span></div>
      <div style="margin-left:12px;">💎 <span id="gemTime">0</span>s</div>
    </header>
    <canvas id="game"></canvas>
  </div>

  <!-- Overlays -->
  <div id="startOL" class="overlay">
    <div class="card">
      <h1>Mars Görevi</h1>
      <p>Parmağını sürükleyerek gemiyi hareket ettir.<br>Elmas → 12s üçlü mavi atış.</p>
      <button class="btn" id="startBtn">BAŞLAT</button>
      <div class="hint">BPC: green=2 • yellow=3 • white=3 • red=4 puan</div>
    </div>
  </div>

  <div id="gameOverOL" class="overlay" style="display:none">
    <div class="card">
      <h1>GAME OVER</h1>
      <p>Tekrar dener misin, çek? 🚀</p>
      <button class="btn" id="retryBtn">TEKRAR</button>
    </div>
  </div>

<script>
(() => {
  /* ---------- Canvas & sizing ---------- */
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d', { alpha: false });
  const scoreTxt = document.getElementById('scoreTxt');
  const gemTimeTxt = document.getElementById('gemTime');
  const DPR = Math.max(1, Math.min(2, window.devicePixelRatio || 1)); // battery-friendly
  let W=0,H=0;
  function resize(){
    const r = window.devicePixelRatio || 1;
    const w = canvas.clientWidth = window.innerWidth;
    const h = canvas.clientHeight = window.innerHeight - document.querySelector('header').offsetHeight;
    canvas.width = Math.round(w * DPR);
    canvas.height = Math.round(h * DPR);
    W = canvas.width; H = canvas.height;
    ctx.setTransform(DPR,0,0,DPR,0,0);
  }
  addEventListener('resize', resize, {passive:true});
  resize();

  /* ---------- Assets (use YOUR repo names) ---------- */
  const SPR = {
    player: 'img/player/bpc_mini.png',
    green : 'mars%20enemy%20green.png',
    yellow: 'Mars%20enemy%20yellow.png',
    white : 'mars%20enemy%20white.png',
    red   : 'mars%20enemy%20red%20.png' // NOTE: space before .png exists in repo
  };
  const IMG = {};
  const toLoad = Object.entries(SPR).map(([k,src]) => new Promise(res=>{
    const im = new Image(); im.src = src; im.onload=()=>res(IMG[k]=im); im.onerror=()=>res(IMG[k]=null);
  }));

  /* ---------- Game state ---------- */
  let running=false, gameOver=false, tPrev=0, score=0;
  let lives=3;
  const player = {x:0,y:0,spd:0.36, w:44, h:44};
  const bullets = [];
  const enemies = [];
  const eBullets = [];
  const particles = [];
  const powerups = []; // diamonds
  let tripleUntil = 0; // timestamp ms

  const POINTS = {green:2, yellow:3, white:3, red:4};

  /* ---------- Helpers ---------- */
  function clamp(v,mi,ma){return Math.max(mi,Math.min(ma,v))}
  function rand(a,b){return Math.random()*(b-a)+a}
  function now(){return performance.now()}
  function collRect(a,b){
    return Math.abs(a.x-b.x) < (a.w+b.w)*0.5 && Math.abs(a.y-b.y) < (a.h+b.h)*0.5;
  }

  // draw masked images to hide square backgrounds (until real PNGs are transparent)
  function drawCircleImage(img, x, y, w, h, flipX=false){
    if(!img) return;
    const r = Math.max(w,h)*0.55;
    ctx.save();
    ctx.beginPath(); ctx.arc(x,y,r,0,Math.PI*2); ctx.clip();
    if(flipX){
      ctx.translate(x,y); ctx.scale(-1,1);
      ctx.drawImage(img, -w/2,-h/2,w,h);
    }else{
      ctx.drawImage(img, x-w/2,y-h/2,w,h);
    }
    ctx.restore();
  }

  function addParticles(x,y,color,count=10,spd=0.6){
    for(let i=0;i<count;i++){
      particles.push({
        x,y, vx:rand(-spd,spd), vy:rand(-spd,spd),
        life:rand(280,460), size:rand(2,3), col:color, born:now()
      });
    }
  }

  /* ---------- Background: Mars texture (no harsh lines) ---------- */
  function drawMarsBG(dt){
    ctx.fillStyle='#2b0f0c'; ctx.fillRect(0,0,canvas.clientWidth,canvas.clientHeight);
    // gradient brown sand
    const grd = ctx.createLinearGradient(0,0,0,canvas.clientHeight);
    grd.addColorStop(0,'#4b1e17'); grd.addColorStop(.6,'#6b2b22'); grd.addColorStop(1,'#58231c');
    ctx.fillStyle = grd; ctx.fillRect(0,0,canvas.clientWidth,canvas.clientHeight);

    // small dark pebbles
    ctx.fillStyle='rgba(0,0,0,.35)';
    for(let i=0;i<70;i++){
      const x = (i*97 + (Date.now()/30))%canvas.clientWidth;
      const y = (i*61)%canvas.clientHeight;
      ctx.fillRect(x,y,2,2);
    }

    // gentle dunes (transparent waves)
    ctx.strokeStyle='rgba(255,180,130,.08)'; ctx.lineWidth=3;
    const step=140, wave = (Date.now()/900)%step;
    for(let y=wave; y<canvas.clientHeight+step; y+=step){
      ctx.beginPath(); ctx.moveTo(0,y);
      for(let x=0;x<=canvas.clientWidth;x+=40){
        ctx.lineTo(x, y + Math.sin((x+Date.now()/500)/120)*6);
      }
      ctx.stroke();
    }
  }

  /* ---------- Spawners ---------- */
  let eTimer=0, pTimer=0, diff=1;
  function spawnEnemy(){
    // pick type by difficulty
    const r=Math.random();
    let type='green';
    if(r>0.75) type='yellow';
    if(r>0.92) type='white';
    if(r>0.97 && diff>2) type='red';

    const w= type==='red'?46:40;
    enemies.push({
      type, x: clamp(rand(30, canvas.clientWidth-30), 30, canvas.clientWidth-30),
      y: -50, w, h:w, img: IMG[type], hp: (type==='red'?3:(type==='yellow'?2:1)),
      spd: (type==='white'?0.22:(type==='yellow'?0.26:(type==='red'?0.24:0.2))),
      shootCd: (type==='red'? rand(900,1400): 0),
      lastShot: now()
    });
  }
  function spawnDiamond(){
    powerups.push({x: rand(30, canvas.clientWidth-30), y: -30, w:22,h:22, spd:0.22});
  }

  /* ---------- Input (touch & mouse) ---------- */
  let dragging=false, dx=0, dy=0;
  function startDrag(e){
    dragging=true;
    const p = point(e);
    dx = p.x - player.x; dy = p.y - player.y;
  }
  function moveDrag(e){
    if(!dragging) return;
    const p=point(e);
    player.x = clamp(p.x - dx, 24, canvas.clientWidth-24);
    player.y = clamp(p.y - dy, 24, canvas.clientHeight-24);
  }
  function endDrag(){ dragging=false; }
  function point(e){
    if(e.touches && e.touches.length){ return {x:e.touches[0].clientX, y:e.touches[0].clientY - document.querySelector('header').offsetHeight}; }
    return {x:e.clientX, y:e.clientY - document.querySelector('header').offsetHeight};
  }
  canvas.addEventListener('pointerdown', e=>{startDrag(e); e.preventDefault();});
  canvas.addEventListener('pointermove', e=>{moveDrag(e); e.preventDefault();});
  canvas.addEventListener('pointerup',   e=>{endDrag(); e.preventDefault();});
  canvas.addEventListener('pointercancel', endDrag);

  /* ---------- Shooting ---------- */
  let shootTick=0;
  function shoot(){
    const speed = -0.55;
    const add = (ox) => bullets.push({x:player.x+ox, y:player.y-24, w:6,h:16, vx:0, vy:speed});
    if(now() < tripleUntil){
      add(-18); add(0); add(18);
    }else{
      add(0);
    }
  }

  /* ---------- UI hearts under player ---------- */
  function drawHeartsUnderPlayer(){
    const txt = '❤️'.repeat(lives);
    ctx.font='20px system-ui,Segoe UI,Roboto';
    ctx.textAlign='center'; ctx.textBaseline='top';
    ctx.fillStyle='#ff5a7a';
    ctx.fillText(txt, player.x, player.y + 28);
  }

  /* ---------- Loop ---------- */
  function resetGame(){
    enemies.length=0; bullets.length=0; eBullets.length=0; particles.length=0; powerups.length=0;
    score=0; lives=3; diff=1; eTimer=0; pTimer=0; tripleUntil=0;
    scoreTxt.textContent='0'; gemTimeTxt.textContent='0';
    player.x = canvas.clientWidth/2; player.y = canvas.clientHeight*0.78;
  }

  function step(ts){
    if(!running){ tPrev=ts; return requestAnimationFrame(step); }
    const dt = Math.min(32, ts - tPrev); tPrev=ts;

    drawMarsBG(dt);

    // update timers
    eTimer += dt; pTimer += dt; shootTick += dt;
    if(eTimer > Math.max(380 - diff*40, 160)){ eTimer=0; spawnEnemy(); if(Math.random()<0.25) spawnEnemy(); }
    if(pTimer > 4500){ pTimer=0; spawnDiamond(); }
    if(score>80) diff=2; if(score>200) diff=3; if(score>400) diff=4;

    // auto shooting
    if(shootTick > (now()<tripleUntil? 160:250)){ shoot(); shootTick=0; }

    // --- update & draw powerups (diamonds) ---
    ctx.fillStyle='#7ee6ff';
    powerups.forEach(p=>{
      p.y += p.spd*dt;
      // draw rhombus diamond
      ctx.save(); ctx.translate(p.x,p.y); ctx.rotate(Math.PI/4);
      ctx.fillStyle='#7fdcff'; ctx.fillRect(-10,-10,20,20);
      ctx.restore();
    });
    // collect
    for(let i=powerups.length-1;i>=0;i--){
      const p=powerups[i];
      if(collRect({...p},{x:player.x,y:player.y,w:player.w,h:player.h})) {
        powerups.splice(i,1);
        tripleUntil = now()+12000;
      } else if(p.y>canvas.clientHeight+30){ powerups.splice(i,1); }
    }
    gemTimeTxt.textContent = Math.max(0, Math.ceil((tripleUntil-now())/1000));

    // --- update & draw enemies ---
    enemies.forEach(e=>{
      e.y += e.spd*dt;
      // red shoots short lasers
      if(e.type==='red' && now()-e.lastShot>e.shootCd){
        e.lastShot = now();
        eBullets.push({x:e.x, y:e.y+12, w:4,h:18, vx:0, vy:0.55, col:'#ff4d4d'});
      }
      // draw with circle-mask; WHITE flipped
      drawCircleImage(e.img, e.x, e.y, e.w, e.h, e.type==='white');
    });
    // cull offscreen
    for(let i=enemies.length-1;i>=0;i--) if(enemies[i].y>canvas.clientHeight+60) enemies.splice(i,1);

    // --- enemy bullets ---
    eBullets.forEach(b=>{
      b.y += b.vy*dt;
      ctx.fillStyle=b.col; ctx.fillRect(b.x-2,b.y-9,4,18);
    });
    for(let i=eBullets.length-1;i>=0;i--){
      const b=eBullets[i];
      if(collRect(b,{x:player.x,y:player.y,w:player.w,h:player.h})){
        eBullets.splice(i,1); hitPlayer();
      } else if(b.y>canvas.clientHeight+30){ eBullets.splice(i,1); }
    }

    // --- bullets ---
    ctx.fillStyle='#7dd3ff';
    bullets.forEach(b=>{ b.x+=b.vx*dt; b.y+=b.vy*dt; ctx.fillRect(b.x-3,b.y-8,6,16);});
    for(let i=bullets.length-1;i>=0;i--){
      const b=bullets[i];
      if(b.y<-30){ bullets.splice(i,1); continue; }
      for(let j=enemies.length-1;j>=0;j--){
        const e=enemies[j];
        if(collRect(b,e)){
          bullets.splice(i,1);
          e.hp--; addParticles(e.x,e.y, e.type==='white'?'#fff':(e.type==='yellow'?'#ffd34d':'#8cff6a'), 10, .7);
          if(e.hp<=0){
            score += POINTS[e.type]; scoreTxt.textContent=score;
            enemies.splice(j,1);
          }
          break;
        }
      }
    }

    // --- player ---
    drawCircleImage(IMG.player, player.x, player.y, player.w, player.h);
    drawHeartsUnderPlayer();

    // collisions (player ↔ enemy)
    for(let i=enemies.length-1;i>=0;i--){
      const e=enemies[i];
      if(collRect(e,{x:player.x,y:player.y,w:player.w,h:player.h})){
        enemies.splice(i,1);
        addParticles(player.x,player.y,'#5ad1ff',14,.8);
        hitPlayer();
      }
    }

    // particles
    particles.forEach(p=>{
      const age = now()-p.born;
      p.x += p.vx*dt; p.y += p.vy*dt;
      const a = 1 - age/p.life;
      if(a<=0) p.dead=true;
      ctx.fillStyle = p.col + Math.max(0, Math.min(1,a)).toFixed(2).replace('0.','0.'); // simple alpha
      ctx.fillRect(p.x,p.y,p.size,p.size);
    });
    for(let i=particles.length-1;i>=0;i--) if(particles[i].dead) particles.splice(i,1);

    if(!gameOver) requestAnimationFrame(step);
  }

  function hitPlayer(){
    lives--; if(lives<=0){ endGame(); }
  }

  function endGame(){
    gameOver=true; running=false;
    document.getElementById('gameOverOL').style.display='flex';
  }

  /* ---------- Boot ---------- */
  Promise.all(toLoad).then(()=>{
    resetGame();
    // start overlay buttons
    document.getElementById('startBtn').onclick=()=>{
      document.getElementById('startOL').style.display='none';
      running=true; gameOver=false; requestAnimationFrame(step);
    };
    document.getElementById('retryBtn').onclick=()=>{
      document.getElementById('gameOverOL').style.display='none';
      resetGame(); running=true; gameOver=false; requestAnimationFrame(step);
    };
    // first frame render
    requestAnimationFrame(step);
  });

})();
</script>
</body>
</html>
