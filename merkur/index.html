<!doctype html>
<html lang="tr">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Babypeacock â€” Mars (Level 2)</title>
<style>
  :root{
    --hud-bg: #09090a;
    --hud-fg: #5fe7b7;
  }
  html,body{height:100%;margin:0;background:#000;}
  body{font-family:Arial,Helvetica,sans-serif;color:#fff;display:flex;flex-direction:column;align-items:center;}
  header{width:100%;background:#061219;color:#cfeef0;padding:10px 12px;display:flex;align-items:center;justify-content:space-between;box-sizing:border-box}
  header .left{display:flex;align-items:center;gap:12px}
  header h1{margin:0;font-size:30px;color:#6aa8ff}
  header .center{font-size:22px;text-align:center}
  header .right{font-weight:800}
  .viewport{width:100%;max-width:420px;aspect-ratio:9/16;margin:12px 0;border-radius:14px;overflow:hidden;background:#2b0e0e;box-shadow:0 0 0 12px #000;}
  canvas{width:100%;height:100%;display:block;background:transparent;}
  .overlay{position:relative}
  .startModal{position:absolute;inset:0;display:flex;flex-direction:column;align-items:center;justify-content:center;pointer-events:auto}
  .startCard{background:rgba(0,0,0,.65);color:#fff;padding:22px;border-radius:12px;text-align:center;max-width:88%}
  .startCard h3{margin:0 0 8px 0;font-size:20px}
  .btn{display:inline-block;margin-top:12px;padding:12px 24px;border-radius:12px;background:#03d9b6;color:#012;cursor:pointer;font-weight:700}
  .hud{width:100%;max-width:420px;display:flex;justify-content:space-around;align-items:center;margin-bottom:6px}
  .hearts{position:relative;text-align:center;padding-bottom:6px}
  .bottomHearts{position:relative; margin:10px 0 6px 0}
  @media (min-width:700px){ .viewport{max-width:360px;aspect-ratio:9/16;} }
</style>
</head>
<body>
<header>
  <div class="left"><h1>Babypeacock</h1><img src="img/player/bpc_mini.png" alt="" style="width:28px;height:28px;object-fit:contain"></div>
  <div class="center">Mars<br/>(Level 2)</div>
  <div class="right">SCORE: <span id="score">0</span></div>
</header>

<div class="hud">
  <div>ðŸ¦š</div>
  <div id="diamondHud">ðŸ’Ž 0s</div>
  <div class="hearts" id="livesHud">ðŸ’–ðŸ’–ðŸ’–</div>
</div>

<div class="viewport overlay" id="viewport">
  <canvas id="cv"></canvas>

  <div class="startModal" id="startModal">
    <div class="startCard">
      <h3>Hold & drag to move â€” auto fire while holding</h3>
      <button class="btn" id="startBtn">BAÅžLA</button>
      <div style="font-size:12px;margin-top:8px;color:#ddd">Tap / hold anywhere to start. Elmas = 3'lÃ¼ yayÄ±lÄ±m</div>
    </div>
  </div>
</div>

<div class="bottomHearts" style="width:100%;max-width:420px;text-align:center">
  <div id="bottomLives" style="font-size:32px">ðŸ’–ðŸ’–ðŸ’–</div>
</div>

<script>
/* -------
 Simple mobile-friendly shooter
 Assets expected (put in same folder structure):
  - img/player/bpc_mini.png
  - merkur/mars_enemy_green.png
  - merkur/mars_enemy_yellow.png
  - merkur/mars_enemy_white.png
 (we draw diamonds as canvas shapes)
 ------- */

const canvas = document.getElementById('cv');
const startModal = document.getElementById('startModal');
const startBtn = document.getElementById('startBtn');
const scoreEl = document.getElementById('score');
const diamondHud = document.getElementById('diamondHud');
const livesHud = document.getElementById('bottomLives');

let W, H, cw, ch;
function resize() {
  // keep canvas internal resolution higher for sharpness
  const rect = document.querySelector('.viewport').getBoundingClientRect();
  W = Math.floor(rect.width);
  H = Math.floor(rect.height);
  canvas.style.width = W + 'px';
  canvas.style.height = H + 'px';
  canvas.width = Math.max(720, W*2);
  canvas.height = Math.max(1280, H*2);
  cw = canvas.width; ch = canvas.height;
}
window.addEventListener('resize', resize);
resize();

const ctx = canvas.getContext('2d', {alpha:true});

/* background: simple mars gradient + faint lines */
function drawBackground() {
  const g = ctx.createLinearGradient(0,0,0,ch);
  g.addColorStop(0,'#5e2b25');
  g.addColorStop(1,'#3b0f0f');
  ctx.fillStyle = g;
  ctx.fillRect(0,0,cw,ch);

  // faint horizontal subtle bands (like earlier screenshot)
  ctx.fillStyle = 'rgba(0,0,0,0.06)';
  const bandH = Math.floor(ch/12);
  for(let i=1;i<12;i++){
    ctx.fillRect(0, i*bandH + Math.sin(perf*0.001+i)*8, cw, 6);
  }
  // stars
  ctx.fillStyle = 'rgba(255,255,255,0.06)';
  for(let i=0;i<150;i++){
    const x = (i*37)%cw;
    const y = ((i*73)%ch);
    ctx.fillRect(x,y,1,1);
  }
}

/* load images */
const IM = {};
function loadImg(key, src){
  const img = new Image();
  img.src = src;
  IM[key] = {img, loaded:false};
  img.onload = ()=> IM[key].loaded = true;
}
loadImg('player','img/player/bpc_mini.png');
loadImg('m_green','merkur/mars_enemy_green.png');
loadImg('m_yellow','merkur/mars_enemy_yellow.png');
loadImg('m_white','merkur/mars_enemy_white.png'); // we'll flip when drawing
// you can put more if needed

/* game state */
let running = false;
let last = 0;
let perf = 0;
let score = 0, diamondsTimer=0;
let lives = 3;
let spreadActiveUntil = 0;

const player = {
  x: null, y: null, r: 46, w:120, h:120, dragging:false
};

const bullets = [];
const enemies = [];
const diamonds = [];
const enemySpawnInterval = 900; // ms
let lastEnemySpawn = 0;

function startGame(){
  // reset
  score = 0; diamondsTimer = 0; lives = 3; spreadActiveUntil = 0;
  enemies.length = 0; bullets.length = 0; diamonds.length = 0;
  lastEnemySpawn = 0;
  player.x = cw/2; player.y = ch - 220;
  updateHUD();
  running = true;
  startModal.style.display = 'none';
  last = performance.now();
  requestAnimationFrame(loop);
}

startBtn.addEventListener('click', startGame);
startModal.addEventListener('pointerdown', (e)=> {
  startGame();
});

/* pointer drag controls */
let activePointer = null;
canvas.addEventListener('pointerdown', (e)=> {
  const p = getPointer(e);
  if(dist(p.x, p.y, player.x, player.y) < 300) {
    player.dragging = true; activePointer = e.pointerId;
    player.x = p.x; player.y = p.y;
  } else {
    // allow drag anywhere to move horizontally
    player.dragging = true; activePointer = e.pointerId;
    player.x = p.x;
  }
  e.preventDefault();
});
canvas.addEventListener('pointermove', (e)=> {
  if(player.dragging && e.pointerId === activePointer) {
    const p = getPointer(e);
    // allow only horizontal sliding mostly, but small Y adjust so feels natural
    player.x = clamp(p.x, 80, cw-80);
    // player.y = clamp(p.y, ch-400, ch-160);
  }
});
canvas.addEventListener('pointerup', (e)=> {
  if(e.pointerId === activePointer) {
    player.dragging = false; activePointer = null;
  }
});
canvas.addEventListener('pointercancel', ()=> { player.dragging = false; activePointer = null; });

function getPointer(e){
  const rect = canvas.getBoundingClientRect();
  const scaleX = canvas.width / rect.width;
  const scaleY = canvas.height / rect.height;
  return {x: (e.clientX - rect.left)*scaleX, y: (e.clientY - rect.top)*scaleY};
}

/* helpers */
function clamp(v,a,b){ return Math.max(a, Math.min(b, v)); }
function dist(x1,y1,x2,y2){ return Math.hypot(x2-x1,y2-y1); }

/* firing */
let lastFire = 0;
const fireRate = 160; // ms single
function tryFire(ts){
  if(!player.dragging) return;
  if(ts - lastFire < fireRate) return;
  lastFire = ts;
  if(performance.now() < spreadActiveUntil){
    // spread -> 3 bullets
    const angs = [-0.22,0,0.22];
    angs.forEach(a=>{
      bullets.push({
        x: player.x,
        y: player.y - 80,
        vx: Math.sin(a)*12,
        vy: -Math.cos(a)*12,
        r:8, color:'#7ff'
      });
    });
  } else {
    bullets.push({x:player.x,y:player.y-80,vx:0,vy:-18,r:8,color:'#7ff'});
  }
}

/* spawn enemies */
function spawnEnemy(){
  // only green and yellow and white (white we will draw flipped)
  const types = ['m_green','m_yellow','m_white'];
  const t = types[Math.floor(Math.random()*types.length)];
  const x = Math.random()*(cw-160)+80;
  const y = -120;
  const speed = 1.2 + Math.random()*1.8;
  enemies.push({type:t,x,y,speed,w:120,h:80, hp:1});
}

/* spawn diamond occasionally */
function spawnDiamond(){
  const x = Math.random()*(cw-200)+100;
  const y = -60;
  const kindRoll = Math.random();
  let kind = 'green'; if(kindRoll>0.7) kind='yellow'; else if(kindRoll>0.45) kind='white';
  diamonds.push({x,y,vy:2.2,kind});
}

/* collisions */
function rectColl(a,b){
  return !(a.x - a.w/2 > b.x + b.w/2 || a.x + a.w/2 < b.x - b.w/2 || a.y - a.h/2 > b.y + b.h/2 || a.y + a.h/2 < b.y - b.h/2);
}

/* update HUD */
function updateHUD(){
  scoreEl.textContent = score;
  diamondHud.textContent = (spreadActiveUntil>performance.now()) ? `ðŸ’Ž ${Math.ceil((spreadActiveUntil-performance.now())/1000)}s` : 'ðŸ’Ž 0s';
  livesHud.textContent = 'ðŸ’–'.repeat(lives);
}

/* main loop */
function loop(ts){
  perf = ts;
  const dt = ts - last;
  last = ts;
  // update
  if(running){
    // spawn enemies
    if(ts - lastEnemySpawn > enemySpawnInterval){
      spawnEnemy(); lastEnemySpawn = ts;
      if(Math.random() < 0.35) spawnDiamond();
    }
    // update bullets
    for(let i=bullets.length-1;i>=0;i--){
      const b = bullets[i];
      b.x += b.vx * (dt/16);
      b.y += b.vy * (dt/16);
      if(b.y < -200 || b.x < -200 || b.x > cw+200) bullets.splice(i,1);
    }
    // update enemies
    for(let i=enemies.length-1;i>=0;i--){
      const e = enemies[i];
      e.y += e.speed * (dt/16) * 1.0;
      // small sinus horizontal drift
      e.x += Math.sin((ts + i*100)/700 + i) * 0.5;
      if(e.y > ch + 200) enemies.splice(i,1);
    }
    // diamonds
    for(let i=diamonds.length-1;i>=0;i--){
      const d = diamonds[i];
      d.y += d.vy * (dt/16);
      if(d.y > ch + 120) diamonds.splice(i,1);
    }

    // collisions: bullet -> enemy
    for(let bi=bullets.length-1;bi>=0;bi--){
      const b = bullets[bi];
      for(let ei=enemies.length-1;ei>=0;ei--){
        const e = enemies[ei];
        const dx = Math.abs(b.x - e.x), dy = Math.abs(b.y - e.y);
        if(dx < 60 && dy < 60){
          // hit
          bullets.splice(bi,1);
          enemies.splice(ei,1);
          score += 1;
          updateHUD();
          break;
        }
      }
    }

    // collisions: enemy -> player
    for(let ei=enemies.length-1;ei>=0;ei--){
      const e = enemies[ei];
      if(Math.abs(e.x - player.x) < 70 && Math.abs(e.y - player.y) < 70){
        enemies.splice(ei,1);
        lives -= 1;
        updateHUD();
        if(lives <= 0){ gameOver(); return; }
      }
    }

    // collisions: diamond -> player
    for(let di=diamonds.length-1;di>=0;di--){
      const d = diamonds[di];
      if(Math.abs(d.x - player.x) < 60 && Math.abs(d.y - player.y) < 60){
        // pickup
        let pts = (d.kind==='green')?2:3;
        score += pts;
        // activate spread for 6s
        spreadActiveUntil = performance.now() + 6000;
        diamonds.splice(di,1);
        updateHUD();
      }
    }

    // firing
    tryFire(ts);
  }

  // draw
  ctx.clearRect(0,0,cw,ch);
  drawBackground();

  // draw diamonds
  for(const d of diamonds){
    // simple blue diamond polygon
    ctx.save();
    const s = 36;
    ctx.translate(d.x,d.y);
    ctx.fillStyle = (d.kind==='green')? '#3eea6a' : (d.kind==='yellow')? '#ffd25b' : '#cfe7ff';
    ctx.beginPath();
    ctx.moveTo(0,-s);
    ctx.lineTo(s,0);
    ctx.lineTo(0,s);
    ctx.lineTo(-s,0);
    ctx.closePath();
    ctx.fill();
    ctx.restore();
  }

  // draw enemies (images)
  for(const e of enemies){
    const imageObj = IM[e.type].img;
    if(IM[e.type] && IM[e.type].loaded){
      const dw = e.w, dh = e.h;
      ctx.save();
      if(e.type === 'm_white'){
        // draw flipped horizontally
        ctx.translate(e.x, e.y);
        ctx.scale(-1,1);
        ctx.drawImage(imageObj, -dw/2, -dh/2, dw, dh);
      } else {
        ctx.drawImage(imageObj, e.x - dw/2, e.y - dh/2, dw, dh);
      }
      ctx.restore();
    } else {
      // fallback rectangle
      ctx.fillStyle = '#555';
      ctx.fillRect(e.x-40, e.y-20, 80, 40);
    }
  }

  // draw bullets
  for(const b of bullets){
    ctx.fillStyle = b.color;
    ctx.beginPath();
    ctx.ellipse(b.x, b.y, b.r, b.r*1.2, 0, 0, Math.PI*2);
    ctx.fill();
  }

  // draw player
  if(IM.player && IM.player.loaded){
    const pimg = IM.player.img;
    const pw = 140, ph = 140;
    ctx.drawImage(pimg, player.x - pw/2, player.y - ph/2, pw, ph);
  } else {
    ctx.fillStyle = '#0f9';
    ctx.beginPath();
    ctx.arc(player.x, player.y, 36, 0, Math.PI*2);
    ctx.fill();
  }

  updateHUD();

  // next frame
  if(running) requestAnimationFrame(loop);
}

/* game over */
function gameOver(){
  running = false;
  startModal.style.display = 'flex';
  startModal.querySelector('.startCard h3').textContent = 'GAME OVER';
  startModal.querySelector('.btn').textContent = 'TEKRAR';
}

/* start positions */
player.x = cw/2; player.y = ch - 220;

/* initial minimal spawn so screen not empty (but game not started until start) */
for(let i=0;i<3;i++){
  enemies.push({type:['m_green','m_yellow'][i%2],x: (i+1)*cw/4,y: (i+1)*-120 - Math.random()*400, speed:1.2 + Math.random()});
}

/* simple ticker to spawn automatically while running */
setInterval(()=>{
  if(running && Math.random()>0.4) spawnEnemy();
  if(running && Math.random()>0.85) spawnDiamond();
}, 800);

/* safe fallback: if images are missing still run â€” user can replace assets later */
Object.values(IM).forEach(o=>{
  o.img.onerror = ()=> console.warn('image missing', o.img.src);
});

/* keep canvas responsive */
resize();
</script>
</body>
</html>
