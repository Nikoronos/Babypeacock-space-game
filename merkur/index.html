<!doctype html>
<html lang="tr">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
<title>Babypeacock â€” Mars (Level 2)</title>
<style>
  :root{--ui:#0fe3cf;--ink:#cfe9ff;--bg:#08121b;--mars:#6a2f1b;}
  html,body{margin:0;height:100%;background:#000;color:var(--ink);font-family:system-ui,Segoe UI,Roboto,Arial}
  #hud{position:fixed;inset:0 0 auto 0;height:56px;background:linear-gradient(180deg,#01060a,transparent);
       display:flex;align-items:center;gap:16px;padding:8px 12px;font-weight:800;letter-spacing:.3px;z-index:30}
  #brand{font-size:22px;color:#87b9ff;text-shadow:0 1px 0 #001}
  #score{margin-left:auto}
  #hearts{display:flex;gap:4px}
  .heart{width:18px;height:18px;background:#d60b4a;border-radius:4px;box-shadow:0 0 8px #ff3b6a inset}
  canvas{display:block;margin:0 auto;touch-action:none;background:#0b0f14}
  /* START overlay */
  .overlay{position:fixed;inset:0;display:flex;align-items:center;justify-content:center;background:rgba(0,0,0,.55);z-index:20}
  .card{background:#0b132b;color:#cde7ff;padding:18px 22px;border-radius:14px;box-shadow:0 8px 24px rgba(0,0,0,.35);text-align:center;min-width:220px}
  #startBtn{appearance:none;border:0;background:#15d1c1;color:#06121e;font-weight:800;padding:10px 18px;border-radius:10px;font-size:16px}
  #startBtn:active{transform:translateY(1px)}
  /* diamond timer */
  #diamond{display:flex;align-items:center;gap:6px}
</style>
</head>
<body>

<div id="hud">
  <div id="brand">Babypeacock ðŸ¦š</div>
  <div>Mars (Level 2)</div>
  <div id="score">SCORE: <span id="scv">0</span></div>
  <div id="diamond">ðŸ’Ž <span id="dleft">0s</span></div>
  <div id="hearts"></div>
</div>

<!-- START OVERLAY -->
<div id="startOverlay" class="overlay">
  <div class="card">
    <h2>Mars (Level 2)</h2>
    <button id="startBtn">START</button>
    <p style="opacity:.7;font-size:12px;margin-top:8px">ðŸ‘† BaÅŸlamak iÃ§in dokun</p>
  </div>
</div>

<canvas id="game" width="420" height="740"></canvas>

<script>
/* ========= CANVAS & STATE ========= */
const cvs = document.getElementById('game');
const ctx = cvs.getContext('2d', { alpha:false });
ctx.imageSmoothingEnabled = false;
let W = cvs.width, H = cvs.height;
let started = false, last = 0, running = true;

/* ========= HUD ========= */
const scv = document.getElementById('scv');
const dleft = document.getElementById('dleft');
const heartsEl = document.getElementById('hearts');
function setHearts(n){
  heartsEl.innerHTML = '';
  for(let i=0;i<n;i++){ const h=document.createElement('div'); h.className='heart'; heartsEl.appendChild(h); }
}

/* ========= ASSETS ========= */
// paths per your repo
const ASSETS = {
  player: 'img/player/bpc_mini.png',
  green:  'mars_enemy_green.png',
  yellow: 'mars_enemy_yellow.png',
  white:  'mars_enemy_white.png',
};
function loadImage(src){ return new Promise(res=>{ const i=new Image(); i.src=src; i.onload=()=>res(i); }); }
let IMG = {};
Promise.all(Object.entries(ASSETS).map(async ([k,v])=>{ IMG[k]=await loadImage(v);})).then(()=>{/* ready */});

function drawFlipped(img,x,y,w,h){ // flip white horizontally
  ctx.save(); ctx.scale(-1,1); ctx.drawImage(img, -x - w, y, w, h); ctx.restore();
}

/* ========= BACKGROUND: Mars noise (no lines) ========= */
function drawMarsBackground(scroll){
  ctx.fillStyle = '#4a1f14'; ctx.fillRect(0,0,W,H);
  // dunes (very soft)
  ctx.fillStyle = '#5b2617';
  for(let i=0;i<4;i++){
    const y = ((i*180 + (scroll*0.4)) % (H+200)) - 200;
    ctx.beginPath();
    ctx.moveTo(0,y+140);
    ctx.bezierCurveTo(W*0.25,y+100, W*0.75,y+180, W,y+140);
    ctx.lineTo(W,y+200); ctx.lineTo(0,y+200); ctx.closePath(); ctx.fill();
  }
  // pebble noise
  const rnd = (n)=>Math.floor(Math.random()*n);
  ctx.fillStyle = '#2d110c';
  for(let i=0;i<60;i++){
    const y = (i*13 + Math.floor(scroll))%H;
    ctx.fillRect((i*37)%W, y, 2, 2);
  }
}

/* ========= PLAYER ========= */
const player = { x:W/2, y:H-110, w:42, h:42, vx:0, lives:3, fireCD:0, tripleUntil:0 };
setHearts(player.lives);

// controls
const keys = {};
addEventListener('keydown',e=>{ keys[e.key]=true; });
addEventListener('keyup',  e=>{ keys[e.key]=false; });
cvs.addEventListener('pointermove',(e)=>{
  const r = cvs.getBoundingClientRect();
  const mx = (e.clientX - r.left) * (cvs.width/r.width);
  player.x = Math.max(20, Math.min(W-20, mx));
});

/* ========= BULLETS / ENEMIES ========= */
let bullets = [], ebullets = [], enemies = [], score = 0, spawnT = 0, scroll = 0;

/* power-ups */
let diamond = null; // {x,y,w,h}

/* ========= SPAWN ========= */
function spawnEnemy(){
  const roll = Math.random();
  let type = 'green';
  if(score>200 && roll<0.25) type='white';
  else if(score>100 && roll<0.5) type='yellow';
  const img = IMG[type];
  const w = 58, h = 58;
  const x = 24 + Math.random()*(W-48-w);
  const y = -h;
  const vyBase = 1.4 + Math.min(2.2, score/250); // kademeli hÄ±z
  enemies.push({type,img,x,y,w,h, hp:type==='green'?3:(type==='yellow'?5:6), vy:vyBase, fire:0});
  // %4 ihtimalle elmas bÄ±rakÄ±cÄ± (ekranÄ±n Ã¼stÃ¼nden kayar)
  if(Math.random()<0.04 && !diamond){
    diamond = {x: x+10, y: y-80, w:20, h:20, vy:1.2};
  }
}

/* ========= LOOP ========= */
function loop(t){
  if(!started || !running) return;
  const dt = Math.min(33, t - (last||t)); last=t;
  scroll += dt*0.05;

  // background
  drawMarsBackground(scroll);

  // player movement
  if(keys['ArrowLeft'])  player.x-=3;
  if(keys['ArrowRight']) player.x+=3;
  player.x = Math.max(20, Math.min(W-20, player.x));

  // shooting
  player.fireCD -= dt;
  const fireRate = player.tripleUntil>t ? 120 : 160;
  if(player.fireCD<=0){
    player.fireCD = fireRate;
    if(player.tripleUntil>t){
      bullets.push({x:player.x,   y:player.y-16, vy:-5});
      bullets.push({x:player.x-10,y:player.y-12, vy:-5});
      bullets.push({x:player.x+10,y:player.y-12, vy:-5});
    }else{
      bullets.push({x:player.x, y:player.y-16, vy:-5});
    }
  }

  // bullets
  ctx.fillStyle = '#7ad8ff';
  for(let i=bullets.length-1;i>=0;i--){
    const b=bullets[i]; b.y+=b.vy;
    if(b.y<-10){ bullets.splice(i,1); continue; }
    ctx.fillRect(b.x-2,b.y-8,4,8);
  }

  // spawn timing
  spawnT -= dt;
  const want = 700 - Math.min(450, score*2); // skor arttÄ±kÃ§a daha sÄ±k
  if(spawnT<=0){ spawnT = want; spawnEnemy(); }

  // enemies
  for(let i=enemies.length-1;i>=0;i--){
    const e=enemies[i];
    e.y += e.vy;

    // enemy fire
    e.fire -= dt;
    if(e.type!=='green' && e.fire<=0 && e.y>30){
      e.fire = (e.type==='yellow'?900:700);
      if(e.type==='yellow'){
        ebullets.push({x:e.x+e.w/2, y:e.y+e.h-6, vy:3.4, col:'#ffd24a'});
      }else{ // white: iki kanat
        ebullets.push({x:e.x+10, y:e.y+e.h-6, vy:3.8, col:'#ffffff'});
        ebullets.push({x:e.x+e.w-10, y:e.y+e.h-6, vy:3.8, col:'#ffffff'});
      }
    }

    // draw
    if(e.type==='white'){ drawFlipped(IMG.white, e.x, e.y, e.w, e.h); }
    else                { ctx.drawImage(e.img, e.x, e.y, e.w, e.h); }

    // bullet hits
    for(let k=bullets.length-1;k>=0;k--){
      const b=bullets[k];
      if(Math.abs(b.x-e.x-e.w/2)<e.w*0.45 && Math.abs(b.y-e.y-e.h/2)<e.h*0.45){
        bullets.splice(k,1); e.hp--;
        if(e.hp<=0){
          // explosion tint by type
          particleBurst(e.x+e.w/2, e.y+e.h/2, e.type);
          enemies.splice(i,1);
          const add = (e.type==='green'?2:(e.type==='yellow'?3:3));
          score += add; scv.textContent=score;
        }
        break;
      }
    }

    // leave screen
    if(e.y>H+40){ enemies.splice(i,1); }
  }

  // enemy bullets
  for(let i=ebullets.length-1;i>=0;i--){
    const b=ebullets[i]; b.y+=b.vy;
    if(b.y>H+10){ ebullets.splice(i,1); continue; }
    ctx.fillStyle = b.col; ctx.fillRect(b.x-2,b.y-6,4,6);
    // hit player
    if(Math.abs(b.x-player.x)<16 && Math.abs(b.y-player.y)<18){
      ebullets.splice(i,1);
      damagePlayer();
    }
  }

  // diamond power-up
  if(diamond){
    diamond.y += 2;
    ctx.fillStyle = '#00e5ff';
    ctx.beginPath(); // small diamond
    ctx.moveTo(diamond.x, diamond.y+diamond.h/2);
    ctx.lineTo(diamond.x+diamond.w/2, diamond.y);
    ctx.lineTo(diamond.x+diamond.w, diamond.y+diamond.h/2);
    ctx.lineTo(diamond.x+diamond.w/2, diamond.y+diamond.h);
    ctx.closePath(); ctx.fill();
    if ( Math.abs(diamond.x+diamond.w/2 - player.x)<18 &&
         Math.abs(diamond.y+diamond.h/2 - player.y)<20 ){
      diamond=null; player.tripleUntil = t + 15000; // 15s
    } else if(diamond.y>H+30){ diamond=null; }
  }
  dleft.textContent = Math.max(0, Math.ceil((player.tripleUntil - t)/1000)) + 's';

  // draw player
  ctx.drawImage(IMG.player, player.x-player.w/2, player.y-player.h/2, player.w, player.h);

  requestAnimationFrame(loop);
}

/* ========= DAMAGE / GAME OVER ========= */
function damagePlayer(){
  player.lives--; setHearts(player.lives);
  particleBurst(player.x,player.y,'white');
  if(player.lives<=0){ running=false; showRetry('GAME OVER'); }
}

/* ========= PARTICLES ========= */
const colors = {green:'#78e08f', yellow:'#ffd24a', white:'#e8f3ff'};
function particleBurst(x,y,type){
  const col = colors[type]||'#fff';
  for(let i=0;i<14;i++){
    const a = Math.random()*Math.PI*2, sp=1+Math.random()*2;
    const px = x, py=y;
    let t=0;
    const life = 420+Math.random()*300;
    const step = ()=>{
      t+=16;
      const dx = Math.cos(a)*sp*(t/16), dy=Math.sin(a)*sp*(t/16);
      ctx.fillStyle = col;
      ctx.fillRect(px+dx, py+dy, 2, 2);
    };
    // tiny immediate paint to suggest explosion (no offscreen buffer)
    step();
  }
}

/* ========= UI: START ========= */
document.getElementById('startBtn').addEventListener('click', ()=>{
  document.getElementById('startOverlay').style.display='none';
  started=true; running=true; last=performance.now();
  requestAnimationFrame(loop);
});

/* ========= SIMPLE RESIZE FIT ========= */
function fit(){
  const scale = Math.min(innerWidth/cvs.width, (innerHeight-60)/cvs.height);
  cvs.style.transformOrigin='top center';
  cvs.style.transform = `scale(${scale})`;
}
addEventListener('resize', fit); fit();

/* ========= TOUCH SHOT HOLD (optional tap to move) ========= */
cvs.addEventListener('pointerdown', e=>{
  const r=cvs.getBoundingClientRect(); const mx=(e.clientX-r.left)*(cvs.width/r.width);
  player.x = Math.max(20, Math.min(W-20, mx));
});

/* ========= FAILSAFE: overscroll prevent ========= */
document.addEventListener('touchmove', e=>{ if(e.target===cvs) e.preventDefault(); }, {passive:false});
</script>
</body>
</html>
